#include "DependenciesMining.h"
#include "Gui.h"
#include "GuiController.h"
#include "SourceLoader.h"
#include "Incremental.h"
#include "Graph.h"
#include "GraphToJson.h"
#include "GraphGeneration.h"
#include "FileSystem.h"
#include "Messages.h"
#include "json/writer.h"
#include <iostream>
#include <cstdlib>
#include <thread>

using namespace dependenciesMining;
using namespace sourceLoader;
using namespace incremental;
using namespace filesystem;
using namespace graph;
using namespace graphGeneration;
using namespace graphToJson;
using namespace gui;
using namespace messages;

using FilePaths = std::vector<std::string>;
using FilePathIDs = std::vector<unsigned>;

// NOTE: Make sure that either there is no .json out file, or the .json out file was generated by mining with the INCREMENTAL_GENERATION flag enabled.

namespace {

	void PrintMainArgInfo(std::ostream& os = std::cerr) {
		os << "MAIN ARGUMENTS:\n\n";
		os << "argv[1]: \"--src\" to mine whole directory with sources (argv[2]: directory/with/sources)\n";
		os << "argv[1]: \"--cmp-db\" to use compilation database (argv[2]: path/to/compile_commands.json)\n";
		os << "argv[3]: (file path) path/to/ignoredFilePaths\n";
		os << "argv[4]: (file path) path/to/ignoredNamespaces\n";
		os << "argv[5]: (file path) path/to/ST-output\n";
	}

	void PrintClangToolInfo(std::string& errorMsg, std::ostream& os = std::cerr) {
		os << "Clang Tool creation failed\n";
		os << errorMsg << '\n';
	}

	void PrintMiningResult(int res, std::ostream& os = std::cout) {
		switch (res)
		{
		case 0:
			os << "\nCOMPILATION FINISHED\n";
			break;

		case 1:
			os << "\nCOMPILATION FAILED\n";
			break;

		case 2:
			os << "\nCOMPILATION FINISHED (with skipped files)\n";
			break;

		default:
			assert(false && "See: `int clang::tooling::ClangTool::run(clang::tooling::ToolAction *Action)`");
			break;
		}
	}

} // namespace

namespace {

	void SerializeDependencies(const Json::Value& graph, Json::Value& ST) {
		const Json::Value& all_dependencies = graph["edges"];
		auto& st_dependencies = ST["dependencies"];

		for (const auto& dependencies : all_dependencies) {
			Json::Value dependency_pack;
			dependency_pack["types"] = dependencies["dependencies"];
			dependency_pack["from"] = dependencies["from"];
			dependency_pack["to"] = dependencies["to"];

			st_dependencies.append(dependency_pack);
		}
	}

	void SerializeFilePaths(Json::Value& ST, const FilePaths& srcs, const FilePaths& headers) {
		for (const auto& path : srcs) 
			ST["sources"].append(path);
		for (const auto& path : headers) 
			ST["headers"].append(path);
	}

	void ProduceJsonOutput(const Graph& dependencyGraph, const SymbolTable& exportedTable, const FilePaths& srcs, const FilePaths& headers, const char* outputPath) {
		assert(outputPath);

		Json::Value jsonST;
		exportedTable.AddJsonSymbolTable(jsonST["structures"]);

		const auto jsonGraph = GetJson(dependencyGraph);

		SerializeDependencies(jsonGraph, jsonST);
		SerializeFilePaths(jsonST, srcs, headers);

		std::ofstream jsonSTFile{outputPath};
		jsonSTFile << jsonST;
		std::cout << "\nGRAPH GENERATED\n";

		assert(jsonSTFile.good());
		assert(std::filesystem::exists(outputPath));
	}

	void ExportDependencies(ClangTool& tool, const SymbolTable& exportedTable, const char* outputPath) {
		assert(outputPath);

		const auto dependenciesGraph = GenerateDependenciesGraph(exportedTable);

		FilePaths srcs, headers;
		GetMinedFiles(tool, srcs, headers);

		ProduceJsonOutput(dependenciesGraph, structuresTable, srcs, headers, outputPath);
	}

} // namespace

int main(int argc, char* argv[]) {
	if (argc != 6) {
		PrintMainArgInfo();
		return EXIT_FAILURE;
	}

	constexpr std::string_view srcOption = "--src";
	constexpr std::string_view databaseOption = "--cmp-db";

	const auto* compilationOption = argv[1];
	const auto* inputPath = argv[2];
	const auto* ignoredFilesPath = argv[3];
	const auto* ignoredNamespacesPath = argv[4];
	const auto* outputPath = argv[5];

	std::unique_ptr<ClangTool> clangTool;
	std::string errorMsg;

#ifdef INCREMENTAL_GENERATION
	if (std::filesystem::exists(outputPath)) {
		ImportST(outputPath, structuresTable);
		ImportSources(outputPath, parsedFiles);
	}
#endif

	SetIgnoredRegions(ignoredFilesPath, ignoredNamespacesPath);

	if (compilationOption == srcOption) {
		clangTool = CreateClangTool(SourceLoader{ inputPath }.GetSources());

	} else if (compilationOption == databaseOption) {
		clangTool = CreateClangTool(inputPath, errorMsg);

	} else {
		PrintMainArgInfo();
		return EXIT_FAILURE;
	}

	if (!clangTool) {
		PrintClangToolInfo(errorMsg);
		return EXIT_FAILURE;
	}

	std::cout << "\n-------------------------------------------------------------------------------------\n\n";
	int miningRes { -1 };

#ifdef GUI
	wxEntryStart(argc, argv);

// NOTE: Might need to set max from clang::tooling::CompilationDatabase::getAllCompileCommands().size().
// FIXME?
#ifdef INCREMENTAL_GENERATION
	const auto max = clangTool->getSourcePaths().size() + (parsedFiles.empty() ? 0 : parsedFiles.size() - 1);
#else
	const auto max = clangTool->getSourcePaths().size();
#endif

	GuiController::GetSingleton().GetGui().ConnectToCancel(&DisruptMining);
	GuiController::GetSingleton().GetGui().OnInit();

	GuiController::GetSingleton().SetTotalUnits(max);

	ConnectToBeginSource([](auto currFileName) {
		PostMessage([currFileName]() { 
			GuiController::GetSingleton().AdvanceAndUpdateGui(currFileName); 
			});
		});

#ifdef INCREMENTAL_GENERATION
	GuiController::GetSingleton().AdvanceGuiProgress(parsedFiles.size());
#endif

	auto worker = std::thread([&miningRes, &clangTool](){ miningRes = MineArchitecture(*clangTool); });

	do
	{
		PollMessage();
		GuiController::GetSingleton().GetGui().Render();
	} while (!GuiController::GetSingleton().IsGuiProgressDone() and !IsMiningDisrupted());

	worker.join();
	
	PrintMiningResult(miningRes);

	ExportDependencies(*clangTool, structuresTable, outputPath);

#else
	miningRes = MineArchitecture(*clangTool);
	
	PrintMiningResult(miningRes);

	ExportDependencies(*clangTool, structuresTable, outputPath);
#endif

	return EXIT_SUCCESS;
}